{
  "name": "eth-lightwallet",
  "version": "2.5.6",
  "description": "A lightweight ethereum javascript wallet.",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/ConsenSys/eth-lightwallet.git"
  },
  "scripts": {
    "build-js": "browserify index.js --s lightwallet -g [ babelify --presets [ es2015 react ] ] | uglifyjs -c > dist/lightwallet.min.js",
    "build-dev": "browserify index.js -o dist/lightwallet.js --s lightwallet -g [ babelify --presets [ es2015 react ] ]",
    "test": "./node_modules/.bin/mocha --reporter spec",
    "coverage": "istanbul cover _mocha -- -R spec; open coverage/lcov-report/index.html"
  },
  "keywords": [
    "ethereum",
    "blockchain",
    "transactions",
    "contracts",
    "wallet"
  ],
  "contributors": [
    {
      "name": "Christian Lundkvist",
      "email": "christian.lundkvist@gmail.com"
    },
    {
      "name": "Tyler Clark",
      "email": "tysclark@gmail.com"
    },
    {
      "name": "Joel Torstensson",
      "email": "me@joeltorstensson.se"
    },
    {
      "name": "Zach Ferland",
      "email": "zachferland@gmail.com"
    },
    {
      "name": "Kevin Jiao",
      "email": "kevin.jiao@berkeley.edu"
    },
    {
      "name": "Marian Oancea",
      "email": "marian.oancea@gmail.com"
    },
    {
      "name": "John McDowall",
      "email": "john@kantan.io"
    },
    {
      "name": "Milad Mostavi",
      "email": "milad.mostavi@gmail.com"
    }
  ],
  "license": "MIT",
  "dependencies": {
    "bitcore-lib": "^0.14.0",
    "bitcore-mnemonic": "^1.2.2",
    "buffer": "^4.9.0",
    "crypto-js": "^3.1.5",
    "elliptic": "^3.1.0",
    "ethereumjs-tx": "^1.1.1",
    "ethereumjs-util": "^5.1.1",
    "rlp": "^2.0.0",
    "scrypt-async": "^1.2.0",
    "tweetnacl": "0.13.2",
    "web3": "^0.19.1"
  },
  "devDependencies": {
    "async": "^1.4.2",
    "babel-preset-es2015": "^6.13.2",
    "babel-preset-react": "^6.11.1",
    "babel-plugin-transform-object-rest-spread": "^6.23.0",
    "babel-plugin-transform-es3-member-expression-literals": "^6.22.0",
    "babel-plugin-transform-es3-property-literals": "^6.22.0",
    "babelify": "^7.3.0",
    "bluebird": "^3.3.1",
    "browserify": "^13.1.0",
    "chai": "^3.0.0",
    "hooked-web3-provider": "christianlundkvist/hooked-web3-provider#updates_web3_14",
    "istanbul": "^0.3.15",
    "mocha": "^2.2.5",
    "uglify-js": "^2.7.2"
  },
  "readme": "# LightWallet\n\nA minimal ethereum javascript wallet.\n\n## About\n\nLightWallet is a HD wallet that can store your private keys encrypted in the browser to allow you to run Ethereum dapps even if you're not running a local Ethereum node. It uses [BIP32][] and [BIP39][] to generate an HD tree of addresses from a randomly generated 12-word seed.\n\nLightWallet is primarily intended to be a signing provider for the [Hooked Web3 provider](https://github.com/ConsenSys/hooked-web3-provider) through the `keystore` module. This allows you to have full control over your private keys while still connecting to a remote node to relay signed transactions. Moreover, the `txutils` functions can be used to construct transactions when offline, for use in e.g. air-gapped coldwallet implementations.\n\nThe default BIP32 HD derivation path is `m/0'/0'/0'/i`.\n\n## Security\n\nPlease note that LightWallet has not been through a comprehensive security review at this point. It is still experimental software, intended for small amounts of Ether to be used for interacting with smart contracts on the Ethereum blockchain. Do not rely on it to store larger amounts of Ether yet.\n\n## Get Started\n\n```\nnpm install eth-lightwallet\n```\n\nThe `eth-lightwallet` package contains `dist/lightwallet.min.js` that can be included in an HTML page:\n\n```html\n<html>\n  <body>\n    <script src=\"lightwallet.min.js\"></script>\n  </body>\n</html>\n```\n\nThe file `lightwallet.min.js` exposes the global object `lightwallet` to the browser which has the two main modules `lightwallet.keystore` and `lightwallet.txutils`.\n\nSample recommended usage with hooked web3 provider:\n\n```js\n// the seed is stored encrypted by a user-defined password\nvar password = prompt('Enter password for encryption', 'password');\n\nkeyStore.createVault({\n  password: password,\n  // seedPhrase: seedPhrase, // Optionally provide a 12-word seed phrase\n  // salt: fixture.salt,     // Optionally provide a salt.\n                             // A unique salt will be generated otherwise.\n  // hdPathString: hdPath    // Optional custom HD Path String\n}, function (err, ks) {\n\n  // Some methods will require providing the `pwDerivedKey`,\n  // Allowing you to only decrypt private keys on an as-needed basis.\n  // You can generate that value with this convenient method:\n  ks.keyFromPassword(password, function (err, pwDerivedKey) {\n    if (err) throw err;\n\n    // generate five new address/private key pairs\n    // the corresponding private keys are also encrypted\n    ks.generateNewAddress(pwDerivedKey, 5);\n    var addr = ks.getAddresses();\n\n    ks.passwordProvider = function (callback) {\n      var pw = prompt(\"Please enter password\", \"Password\");\n      callback(null, pw);\n    };\n\n    // Now set ks as transaction_signer in the hooked web3 provider\n    // and you can start using web3 using the keys/addresses in ks!\n  });\n});\n```\n\nSample old-style usage with hooked web3 provider (still works, but less secure because uses fixed salts).\n\n```js\n// generate a new BIP32 12-word seed\nvar secretSeed = lightwallet.keystore.generateRandomSeed();\n\n// the seed is stored encrypted by a user-defined password\nvar password = prompt('Enter password for encryption', 'password');\nlightwallet.keystore.deriveKeyFromPassword(password, function (err, pwDerivedKey) {\n\nvar ks = new lightwallet.keystore(secretSeed, pwDerivedKey);\n\n// generate five new address/private key pairs\n// the corresponding private keys are also encrypted\nks.generateNewAddress(pwDerivedKey, 5);\nvar addr = ks.getAddresses();\n\n// Create a custom passwordProvider to prompt the user to enter their\n// password whenever the hooked web3 provider issues a sendTransaction\n// call.\nks.passwordProvider = function (callback) {\n  var pw = prompt(\"Please enter password\", \"Password\");\n  callback(null, pw);\n};\n\n// Now set ks as transaction_signer in the hooked web3 provider\n// and you can start using web3 using the keys/addresses in ks!\n});\n```\n\n## `keystore` Function definitions\n\nThese are the interface functions for the keystore object. The keystore object holds a 12-word seed according to [BIP39][] spec. From this seed you can generate addresses and private keys, and use the private keys to sign transactions.\n\nNote: Addresses and RLP encoded data are in the form of hex-strings. Hex-strings do not start with `0x`.\n\n### `keystore.createVault(options, callback)`\n\nThe current recommended keystore construction method. Has popular defaults, handles salting internally, and is the easiest interface to use.\n\n#### Options\n\n* password: (mandatory) A string used to encrypt the vault when serialized.\n* seedPhrase: (optional) A twelve-word mnemonic used to generate all accounts.\n* salt: (optional) The user may supply the salt used to encrypt & decrypt the vault, otherwise a random salt will be generated.\n* hdPathString: (optional) The user may provide a `BIP39` compliant HD Path String. The default is `m/0'/0'/0'`.\n\n### `keystore.keyFromPassword(password, callback)`\n\nThis instance method uses any internally-configured salt to return the appropriate `pwDerivedKey`.\n\nTakes the user's password as input and generates a symmetric key of type `Uint8Array` that is used to encrypt/decrypt the keystore.\n\n### `keystore.deriveKeyFromPassword(password, callback)` (deprecated)\n\nDeprecated class method that uses a fixed salt to derive a `pwDerivedKey` from a password.\n\nTakes the user's password as input and generates a symmetric key of type `Uint8Array` that is used to encrypt/decrypt the keystore.\n\n### `keystore(seed, pwDerivedKey [,hdPathString])` (deprecated)\n\nConstructor of the keystore object. The seed `seed` is encrypted with `pwDerivedKey` and stored encrypted in the keystore.\n\nThis method has been deprecated because it relies on a hard-coded salt, but still exists for backwards-compatibility.\n\n#### Inputs\n\n* words: string defining a 12-word seed according to [BIP39][]\n* pwDerivedKey: symmetric key to encrypt the seed (Uint8Array)\n* hdPathString: optional alternate HD derivation path to use\n\n### `keystore.isDerivedKeyCorrect(pwDerivedKey)`\n\nReturns `true` if the derived key can decrypt the seed, and returns `false` otherwise.\n\n### `keystore.generateRandomSeed([extraEntropy])`\n\nGenerates a string consisting of a random 12-word seed and returns it. If the optional argument string `extraEntropy` is present the random data from the Javascript RNG will be concatenated with `extraEntropy` and then hashed to produce the final seed. The string `extraEntropy` can be something like entropy from mouse movements or keyboard presses, or a string representing dice throws.\n\n### `keystore.isSeedValid(seed)`\n\nChecks if `seed` is a valid 12-word seed according to the [BIP39][] specification.\n\n### `keystore.addHdDerivationPath(hdPathString, pwDerivedKey, info)`\n\nAdds the HD derivation path `hdPathString` to the keystore. The `info` structure denotes the curve and purpose for the keys in that path. Supported structures are\n\n* `{curve: 'secp256k1', purpose: 'sign'}`\n* `{curve: 'curve25519', purpose: 'asymEncrypt'}`\n\n### `keystore.setDefaultHdDerivationPath(hdPathString)`\n\nSet the default HD Derivation path. This path will be used if the `hdPathString` is omitted from other functions. This is also the path that's used if the keystore is used with the Hooked Web3 Provider.\n\n### `keystore.generateNewAddress(pwDerivedKey, [num,] [hdPathString])`\n\nAllows the vault to generate additional internal address/private key pairs.\n\nThe simplest usage is `ks.generateNewAddress(pwDerivedKey)`.\n\nGenerates `num` new address/private key pairs (defaults to 1) in the keystore from the seed phrase, which will be returned with calls to `ks.getAddresses()`.\n\n### `keystore.deserialize(serialized_keystore)`\n\nTakes a serialized keystore string `serialized_keystore` and returns a new keystore object.\n\n### `keystore.serialize()`\n\nSerializes the current keystore object into a JSON-encoded string and returns that string.\n\n### `keystore.getAddresses()`\n\nReturns a list of hex-string addresses currently stored in the keystore.\n\n### `keystore.getSeed(pwDerivedKey)`\n\nGiven the pwDerivedKey, decrypts and returns the users 12-word seed.\n\n### `keystore.exportPrivateKey(address, pwDerivedKey)`\n\nGiven the derived key, decrypts and returns the private key corresponding to `address`. This should be done sparingly as the recommended practice is for the `keystore` to sign transactions using `signing.signTx`, so there is normally no need to export private keys.\n\n## `upgrade` Function definitions\n\n### `keystore.upgradeOldSerialized(oldSerialized, password, callback)`\n\nTakes a serialized keystore in an old format and a password. The callback takes the upgraded serialized keystore as its second argument.\n\n\n### `keystore.generateNewEncryptionKeys(pwDerivedKey [, num, hdPathString])`\n\nGenerate `num` new encryption keys at the path `hdPathString`. Only\ndefined when the purpose of the HD path is `asymEncrypt`.\n\n### `keystore.getPubKeys([hdPathString])`\n\nReturn the pubkeys at `hdPathString`, or at the default HD path. Only\ndefined when the purpose of the HD path is `asymEncrypt`.\n\n## `signing` Function definitions\n\n### `signing.signTx(keystore, pwDerivedKey, rawTx, signingAddress, hdPathString)`\n\nSigns a transaction with the private key corresponding to `signingAddress`.\n\n#### Inputs\n\n* `keystore`: An instance of the keystore with which to sign the TX with.\n* `pwDerivedKey`: the users password derived key (Uint8Array)\n* `rawTx`: Hex-string defining an RLP-encoded raw transaction.\n* `signingAddress`: hex-string defining the address to send the transaction from.\n* `hdPathString`: (Optional) A path at which to create the encryption keys.\n\n#### Return value\n\nHex-string corresponding to the RLP-encoded raw transaction.\n\n### `signing.signMsg(keystore, pwDerivedKey, rawMsg, signingAddress, hdPathString)`\n\nCreates and signs a sha3 hash of a message with the private key corresponding to `signingAddress`.\n\n#### Inputs\n\n* `keystore`: An instance of the keystore with which to sign the TX with.\n* `pwDerivedKey`: the users password derived key (Uint8Array)\n* `rawMsg`: Message to be signed\n* `signingAddress`: hex-string defining the address corresponding to the signing private key.\n* `hdPathString`: (Optional) A path at which to create the encryption keys.\n\n#### Return value\n\nSigned hash as signature object with v, r and s values.\n\n### `signing.signMsgHash(keystore, pwDerivedKey, msgHash, signingAddress, hdPathString)`\n\nSigns a sha3 message hash with the private key corresponding to `signingAddress`.\n\n#### Inputs\n\n* `keystore`: An instance of the keystore with which to sign the TX with.\n* `pwDerivedKey`: the users password derived key (Uint8Array)\n* `msgHash`: SHA3 hash to be signed\n* `signingAddress`: hex-string defining the address corresponding to the signing private key.\n* `hdPathString`: (Optional) A path at which to create the encryption keys.\n\n#### Return value\n\nSigned hash as signature object with v, r and s values.\n\n### `concatSig(signature)`\n\nConcatenates signature object to return signature as hex-string in the same format as `eth_sign` does.\n\n#### Inputs\n\n* `signature`: Signature object as returned from `signMsg` or ``signMsgHash`.\n\n#### Return value\n\nConcatenated signature object as hex-string.\n\n### `recoverAddress(rawMsg, v, r, s)`\n\nRecovers the signing address from the message `rawMsg` and the signature `v, r, s`.\n\n\n## `encryption` Function definitions\n\n### `encryption.multiEncryptString(keystore, pwDerivedKey, msg, myPubKey, theirPubKeyArray [, hdPathString])`\n\n**NOTE:** The format of encrypted messages has not been finalized and may change at any time, so only use this for ephemeral messages that do not need to be stored encrypted for a long time.\n\nEncrypts the string `msg` with a randomly generated symmetric key, then encrypts that symmetric key assymetrically to each of the pubkeys in `theirPubKeyArray`. The encrypted message can then be read only by sender and the holders of the private keys corresponding to the public keys in `theirPubKeyArray`. The returned object has the following form, where nonces and ciphertexts are encoded in base64:\n\n```js\n{ version: 1,\n  asymAlg: 'curve25519-xsalsa20-poly1305',\n  symAlg: 'xsalsa20-poly1305',\n  symNonce: 'SLmxcH3/CPMCCJ7orkI7iSjetRlMmzQH',\n  symEncMessage: 'iN4+/b5InlsVo5Bc7GTmaBh8SgWV8OBMHKHMVf7aq5O9eqwnIzVXeX4yzUWbw2w=',\n  encryptedSymKey:\n   [ { nonce: 'qcNCtKqiooYLlRuIrNlNVtF8zftoT5Cb',\n       ciphertext: 'L8c12EJsFYM1K7udgHDRrdHhQ7ng+VMkzOdVFTjWu0jmUzpehFeqyoEyg8cROBmm' },\n     { nonce: 'puD2x3wmQKu3OIyxgJq2kG2Hz01+dxXs',\n       ciphertext: 'gLYtYpJbeFKXL/WAK0hyyGEelaL5Ddq9BU3249+hdZZ7xgTAZVL8tw+fIVcvpgaZ' },\n     { nonce: '1g8VbftPnjc+1NG3zCGwZS8KO73yjucu',\n       ciphertext: 'pftERJOPDV2dfP+C2vOwPWT43Q89V74Nfu1arNQeTMphSHqVuUXItbyCMizISTxG' },\n     { nonce: 'KAH+cCxbFGSDjHDOBzDhMboQdFWepvBw',\n       ciphertext: 'XWmmBmxLEyLTUmUBiWy2wDqedubsa0KTcufhKM7YfJn/eHWhDDptMxYDvaKisFmn' } ] }\n```\n\nNote that no padding is applied to `msg`, so it's possible to deduce the length of the string `msg` from the ciphertext. If you don't want this information to be known, please apply padding to `msg` before calling this function.\n\n### `encryption.multiDecryptString(keystore, pwDerivedKey, encMsg, theirPubKey, myPubKey [, hdPathString])`\n\nDecrypt a message `encMsg` created with the function\n`multiEncryptString()`. If successful, returns the original message\nstring. If not successful, returns `false`.\n\n## `txutils` Function definitions\n\nThese are the interface functions for the `txutils` module. These functions will create RLP encoded raw unsigned transactions which can be signed using the `keystore.signTx()` command.\n\n### `txutils.createContractTx(fromAddress, txObject)`\n\nUsing the data in `txObject`, creates an RLP-encoded transaction that will create the contract with compiled bytecode defined by `txObject.data`. Also computes the address of the created contract.\n\n#### Inputs\n\n* `fromAddress`: Address to send the transaction from\n* `txObject.gasLimit`: Gas limit\n* `txObject.gasPrice`: Gas price\n* `txObject.value`: Endowment (optional)\n* `txObject.nonce`: Nonce of `fromAddress`\n* `txObject.data`: Compiled code of the contract\n\n#### Output\n\nObject `obj` with fields\n\n* `obj.tx`: RLP encoded transaction (hex string)\n* `obj.addr`: Address of the created contract\n\n### `txutils.functionTx(abi, functionName, args, txObject)`\n\nCreates a transaction calling a function with name `functionName`, with arguments `args` conforming to `abi`. The function is defined in a contract with address `txObject.to`.\n\n#### Inputs\n\n* `abi`: Json-formatted ABI as returned from the `solc` compiler\n* `functionName`: string with the function name\n* `args`: Array with the arguments to the function\n* `txObject.to`: Address of the contract\n* `txObject.gasLimit`: Gas limit\n* `txObject.gasPrice`: Gas price\n* `txObject.value`: Value to send\n* `txObject.nonce`: Nonce of sending address\n\n#### Output\n\nRLP-encoded hex string defining the transaction.\n\n\n### `txutils.valueTx(txObject)`\n\nCreates a transaction sending value to `txObject.to`.\n\n#### Inputs\n\n* `txObject.to`: Address to send to\n* `txObject.gasLimit`: Gas limit\n* `txObject.gasPrice`: Gas price\n* `txObject.value`: Value to send\n* `txObject.nonce`: Nonce of sending address\n\n#### Output\n\nRLP-encoded hex string defining the transaction.\n\n## Examples\n\nSee the file `example_usage.js` for usage of `keystore` and `txutils` in node.\n\nSee the file `example_web.html` for an example of how to use the LightWallet keystore together with the Hooked Web3 Provider in the browser.\n\n## Tests\n\nRun all tests:\n\n```\nnpm run test\nnpm run coverage\n```\n\n[BIP39]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n[BIP32]: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n\n## License\n\nMIT License.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ConsenSys/eth-lightwallet/issues"
  },
  "_id": "eth-lightwallet@2.5.6",
  "dist": {
    "shasum": "2f248c9a8b04077cd97dae24598bcf17164ee229"
  },
  "_from": "eth-lightwallet@2.5",
  "_resolved": "https://registry.npmjs.org/eth-lightwallet/-/eth-lightwallet-2.5.6.tgz"
}
